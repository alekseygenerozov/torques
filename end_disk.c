/**
 */
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <unistd.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/time.h>
//#include <iostream>
//#include <uuid/uuid.h>
#include "rebound.h"
#include "tools.h"
#include "output.h"
#define MAX_SIZE 1000



// void heartbeat(struct reb_simulation* const r);
struct tup
{
	double sum;
	double c;
};

struct tup comp_sum(double sum,  double val, double c){
    struct tup res;
    double yy=val-c;
    double tt=sum+yy;
    res.c=(tt-sum)-yy;
    res.sum= tt;

    return res;
}

void out(char* pre, char* tag, double out){
    char fname[80]="";
    strcat(fname, pre);
    strcat(fname, "_");
    strcat(fname, tag);
    FILE* f = fopen(fname, "w");
    fprintf(f, "%0.10e\n", out);
    fclose(f);

}

int main(int argc, char* argv[]){
    struct reb_simulation* r = reb_create_simulation();
    r->G         = 1;
    int opt; 
    char* tag="a";
    char* e_test="0.7";
    char* e_in="0.7";
    char* a_test="0.99"; 
    char* ang_test="0.0";
    char* flag="0";
    char* points="1001";
    char* q_disk="0.0";
    char* disk_tag="1";


    static struct option long_options[] =
        {
          /* These options set a flag. */
          {"ein", required_argument, NULL, 'i'}, 
          {"atest", required_argument, NULL, 'a'},
          {"etest", required_argument, NULL, 'e'},
          {"pomega", required_argument, NULL, 'o'},
          {"flag",    required_argument, NULL, 'f'},
          {"dtag",    required_argument, NULL, 'd'},
          {0, 0, 0, 0}
        };

    while((opt = getopt_long(argc, argv, "e:a:o:n:f:q:d:", long_options, NULL)) != -1)  
    {  
        // printf("%d \n", opt);
        switch(opt)  
        {  
            case 'e':  
                e_test=(optarg);
                break;
            case 'a': 
                a_test=(optarg);
                break;
            case 'i':
                e_in=(optarg);
                break;
            case 'o':
                ang_test=(optarg);
                break;
            case 'n':
                points=(optarg);
                break;
            case 'f':
                flag=(optarg);
                if (atoi(flag)!=0)
                    tag="b";
                break;
            case 'q':
                q_disk=(optarg);
                break;
            case 'd':
                disk_tag=(optarg);
                break;

        }  
    }  


    char line[MAX_SIZE];
    int N=0;
    int offset = atoi(flag);
    if (offset!=0){
    	tag="b";
    	offset=1;
    }
 		   
    const int bins = atoi(points);
    const double qq = atof(q_disk);
    const double m = 1.0/4e6/bins;
    const double e_test_f=atof(e_test);
    const double a_test_f=atof(a_test);
    const double ang_test_f=atof(ang_test);
    const double ang_test_rad=ang_test_f*(M_PI/180.0);

    // Initial conditions
    struct reb_particle star = {0};
    star.m = 1;
    reb_add(r, star);

    //Read in disk data--generated by another script.
    char aa[80]="";
    strcat(aa, "a_");
    strcat(aa, disk_tag);
    strcat(aa, ".txt");
    FILE* AA = fopen(aa, "r");
    FILE* AA2= fopen(aa, "r");


    char oo[80]="";
    strcat(oo, "Om_");
    strcat(oo, disk_tag);
    strcat(oo, ".txt");
    FILE* OM = fopen(oo, "r");

    char oo2[80]="";
    strcat(oo2, "om_");
    strcat(oo2, disk_tag);
    strcat(oo2, ".txt");
    FILE* OM2 = fopen(oo2, "r");


    char ii[80]="";
    strcat(ii, "inc_");
    strcat(ii, disk_tag);
    strcat(ii, ".txt");
    FILE* INC = fopen(ii, "r");
    double a, e, inc, omega, Omega, M;
    printf("%lf\n", atof(argv[1]));


    while((fgets(line, sizeof(line), AA2) != NULL) && (N<MAX_SIZE)){
        N+=1;        
        fscanf(AA, "%lf", &a);
        fscanf(OM, "%lf", &Omega);
        fscanf(OM2, "%lf", &omega);
        fscanf(INC, "%lf", &inc);
        e=pow(a, qq)*atof(e_in);

        for (int j=0; j<bins; j++){
            struct reb_particle pt;
            M = (j+0.5*offset)*((2.*M_PI)/(double)bins);
            double f = reb_tools_M_to_f(e, M);
            pt = reb_tools_orbit_to_particle(r->G, r->particles[0], m, a, e, inc, Omega, omega, f);
            reb_add(r, pt);
        }
    }
    printf("%d\n", N);

    fclose(AA);
    fclose(OM);
    fclose(OM2);
    fclose(INC);


    double* farr=malloc(bins*sizeof(double));
    for (int j=0; j<bins; j++){
        struct reb_particle pt;
        double M = (j+0.5*offset)*((2.*M_PI)/(double)bins);
        double f = reb_tools_M_to_f(atof(e_test), M);
        pt = reb_tools_orbit2d_to_particle(r->G, r->particles[0], m, a_test_f, e_test_f, ang_test_rad, f);

        reb_add(r, pt);
        farr[j]=f;

    }


	double ex=e_test_f*cos(ang_test_rad);
 	double ey=e_test_f*sin(ang_test_rad);

    double c = 0;
    double c2 = 0;
    double c3 = 0;
    double c4 = 0;

    double forcexTot=0;
    double forceyTot=0;
    double forcezTot=0;

    double taux=0;
    double tauy=0;
    double tauz=0;
    double tauzTot=0;
    double edotx=0;
    double edoty=0;
    double jz=0;
    double ieDot=0;
    double ieDot2=0;
    double ieDot3=0;
    double pre=1.0;
    double tmp=0;
    struct tup res;

    printf("%lf\n", r->particles[N*bins].x);
    for (int i=1; i<N*bins+1; i++){
        double x=r->particles[i].x;
        double y=r->particles[i].y;
        double z=r->particles[i].z;

        for (int j=1; j<bins+1; j++){
            double xTest=r->particles[N*bins+j].x;
            double yTest=r->particles[N*bins+j].y;
            double zTest=r->particles[N*bins+j].z;
            double vx=r->particles[N*bins+j].vx;
            double vy=r->particles[N*bins+j].vy;
            double vz=r->particles[N*bins+j].vz;
            double phi = farr[j-1];

            double d=pow(pow(x-xTest, 2.)+pow(y-yTest,2.)+pow(z-zTest,2.),0.5);
            double forcex = -pow(m,2.0)/pow(d,3.0)*(xTest-x);
            double forcey = -pow(m,2.0)/pow(d,3.0)*(yTest-y);
            double forcez = -pow(m,2.0)/pow(d,3.0)*(zTest-z);

            forcexTot+=forcex;
            forceyTot+=forcey;
            forcezTot+=forcez;

            taux= (yTest*forcez-zTest*forcey);
            tauy= -(xTest*forcez-zTest*forcex);
            tauz= (xTest*forcey-yTest*forcex);

            // tauzTot+=tauz;
            res=comp_sum(tauzTot, tauz, c);
            c=res.c;
            tauzTot=res.sum;
            //Angular momentum of test orbit--Take this to be in the xy plane
            jz = xTest*vy-yTest*vx;
            double fr=forcex*cos(phi+ang_test_rad)+forcey*sin(phi+ang_test_rad);
            double vr=vx*cos(phi+ang_test_rad)+vy*sin(phi+ang_test_rad);

            tmp = pre*(-jz*fr/e_test_f*(cos(phi)));
            res=comp_sum(ieDot2, tmp, c2);
            c2=res.c;
            ieDot2=res.sum;

            tmp = pre*(-jz*fr/e_test_f*(cos(phi))+tauz*vr/e_test_f*(2/e_test_f+cos(phi)));
            res=comp_sum(ieDot, tmp, c3);
            c3=res.c;
            ieDot=res.sum;

            edotx=forcey*jz+(vy*tauz-vz*tauy);
            edoty=-forcex*jz-(vx*tauz-vz*taux);
            tmp=((ex*edoty-ey*edotx)/(e_test_f*e_test_f));
            res=comp_sum(ieDot3, tmp, c4);
            c4=res.c;
            ieDot3=res.sum;


       }

    }
    // double ieDot=(ex*edoty-ey*edotx)/pow(e_test_f, 2.);

    char tag2[80]="";
    strcat(tag2, "N");
    snprintf(tag2+strlen(tag2), sizeof(tag2), "%d", N);
    strcat(tag2, "_");
    strcat(tag2, tag);
    strcat(tag2, "_e");
    strcat(tag2, e_test);
    strcat(tag2, "_a");
    strcat(tag2, a_test);
    strcat(tag2, "_o");
    strcat(tag2, ang_test);
    strcat(tag2, "_q");
    strcat(tag2, q_disk);
    strcat(tag2, "_ein");
    strcat(tag2, e_in);
    strcat(tag2, "_dt");
    strcat(tag2, disk_tag);


    out("tau", tag2, tauzTot);
    out("i", tag2, ieDot);
    out("i2", tag2, ieDot2);
    out("i3", tag2, ieDot3);

    return 0;
}



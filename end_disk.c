/**
 */
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <unistd.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/time.h>
#include <omp.h>
//#include <iostream>
//#include <uuid/uuid.h>
#include "rebound.h"
#include "tools.h"
#include "output.h"
#define MAX_SIZE 1000
#define MAX_BINS 1000000



typedef struct {
  double *array;
  size_t used;
  size_t size;
} Array;

void initArray(Array *a, size_t initialSize) {
  a->array = (double *)malloc(initialSize * sizeof(double));
  a->used = 0;
  a->size = initialSize;
}

void insertArray(Array *a, double element) {
  // a->used is the number of used entries, because a->array[a->used++] updates a->used only *after* the array has been accessed.
  // Therefore a->used can go up to a->size 
  if (a->used == a->size) {
    a->size *= 2;
    a->array = (double *)realloc(a->array, a->size * sizeof(double));
  }
  a->array[a->used++] = element;
}

void freeArray(Array *a) {
  free(a->array);
  a->array = NULL;
  a->used = a->size = 0;
}

// void heartbeat(struct reb_simulation* const r);
struct tup
{
	double sum;
	double c;
};

struct tup comp_sum(double sum,  double val, double c){
    struct tup res;
    double yy=val-c;
    double tt=sum+yy;
    res.c=(tt-sum)-yy;
    res.sum= tt;

    return res;
}

double sum_arr(double* arr, int N){
    double sum=0;
    int i=0;
    double c=0;
    struct tup res;

    for (i=0; i<N; i++){
        res=comp_sum(sum, arr[i], c);
        sum=res.sum;
        c=res.c;
    }

    return sum;
}

void out(char* pre, char* tag, double out){
    char fname[80]="";
    strcat(fname, pre);
    strcat(fname, "_");
    strcat(fname, tag);
    FILE* f = fopen(fname, "w");
    fprintf(f, "%0.10e\n", out);
    fclose(f);

}

void outa(char* pre, char* tag, double out){
    char fname[80]="";
    strcat(fname, pre);
    strcat(fname, "_");
    strcat(fname, tag);
    FILE* f = fopen(fname, "a");
    fprintf(f, "%0.10e\n", out);
    fclose(f);

}

int main(int argc, char* argv[]){
    struct reb_simulation* r = reb_create_simulation();
    r->G         = 1;
    int opt; 
    char* tag="a";
    char* e_test="0.7";
    char* e_in="0.7";
    char* a_test="0.99"; 
    char* ang_test="0.0";
    char* flag="0";
    char* points="1001";
    char* q_disk="0.0";
    char* disk_tag="1";


    static struct option long_options[] =
        {
          /* These options set a flag. */
          {"ein", required_argument, NULL, 'i'}, 
          {"atest", required_argument, NULL, 'a'},
          {"etest", required_argument, NULL, 'e'},
          {"pomega", required_argument, NULL, 'o'},
          {"flag",    required_argument, NULL, 'f'},
          {"dtag",    required_argument, NULL, 'd'},
          {0, 0, 0, 0}
        };

    while((opt = getopt_long(argc, argv, "e:a:o:n:f:q:d:", long_options, NULL)) != -1)  
    {  
        // printf("%d \n", opt);
        switch(opt)  
        {  
            case 'e':  
                e_test=(optarg);
                break;
            case 'a': 
                a_test=(optarg);
                break;
            case 'i':
                e_in=(optarg);
                break;
            case 'o':
                ang_test=(optarg);
                break;
            case 'n':
                points=(optarg);
                break;
            case 'f':
                flag=(optarg);
                if (atoi(flag)!=0)
                    tag="b";
                break;
            case 'q':
                q_disk=(optarg);
                break;
            case 'd':
                disk_tag=(optarg);
                break;

        }  
    }  


    char line[MAX_SIZE];
    int N=0;
    int offset = atoi(flag);
    if (offset!=0){
    	tag="b";
    	offset=1;
    }
 		   
    const int bins = atoi(points);
    const double qq = atof(q_disk);
    const double m = 1.0/4e6/bins;
    const double e_test_f=atof(e_test);
    const double a_test_f=atof(a_test);
    const double ang_test_f=atof(ang_test);
    const double ang_test_rad=ang_test_f*(M_PI/180.0);

    // Initial conditions
    struct reb_particle star = {0};
    star.m = 1;
    reb_add(r, star);

    //Read in disk data--generated by another script.
    char aa[80]="";
    strcat(aa, "a_");
    strcat(aa, disk_tag);
    strcat(aa, ".txt");
    FILE* AA = fopen(aa, "r");
    FILE* AA2= fopen(aa, "r");


    char oo[80]="";
    strcat(oo, "Om_");
    strcat(oo, disk_tag);
    strcat(oo, ".txt");
    FILE* OM = fopen(oo, "r");

    char oo2[80]="";
    strcat(oo2, "om_");
    strcat(oo2, disk_tag);
    strcat(oo2, ".txt");
    FILE* OM2 = fopen(oo2, "r");


    char ii[80]="";
    strcat(ii, "inc_");
    strcat(ii, disk_tag);
    strcat(ii, ".txt");
    FILE* INC = fopen(ii, "r");
    double a, e, inc, omega, Omega, M;

    // printf("%lf\n", atof(argv[1]));
    Array xs, ys, zs, vxs, vys, vzs;
    initArray(&xs, bins);
    initArray(&ys, bins);
    initArray(&zs, bins);
    initArray(&vxs, bins);
    initArray(&vys, bins);
    initArray(&vzs, bins);


    while((fgets(line, sizeof(line), AA2) != NULL) && (N<MAX_SIZE)){
        N+=1;  
        fscanf(AA, "%lf", &a);
        fscanf(OM, "%lf", &Omega);
        fscanf(OM2, "%lf", &omega);
        fscanf(INC, "%lf", &inc);
        e=pow(a, qq)*atof(e_in);

        // printf("%lf\n", e);
        for (int j=0; j<bins; j++){
            struct reb_particle pt;
            M = (j+0.5*offset)*((2.*M_PI)/(double)bins);
            double f = reb_tools_M_to_f(e, M);
            pt = reb_tools_orbit_to_particle(r->G, r->particles[0], m, a, e, inc, Omega, omega, f);
            
            insertArray(&xs, pt.x);
            insertArray(&ys, pt.y);
            insertArray(&zs, pt.z);
            insertArray(&vxs, pt.vx);
            insertArray(&vys, pt.vy);
            insertArray(&vzs, pt.vz);



        }
    }

    printf("%d\n", N);

    fclose(AA);
    fclose(OM);
    fclose(OM2);
    fclose(INC);


    double* farr=malloc(bins*sizeof(double));
    for (int j=0; j<bins; j++){
        struct reb_particle pt;
        double M = (j+0.5*offset)*((2.*M_PI)/(double)bins);
        double f = reb_tools_M_to_f(atof(e_test), M);
        pt = reb_tools_orbit2d_to_particle(r->G, r->particles[0], m, a_test_f, e_test_f, ang_test_rad, f);

        insertArray(&xs, pt.x);
        insertArray(&ys, pt.y);
        insertArray(&zs, pt.z);
        insertArray(&vxs, pt.vx);
        insertArray(&vys, pt.vy);
        insertArray(&vzs, pt.vz);
        farr[j]=f;

    }

	double ex=e_test_f*cos(ang_test_rad);
 	double ey=e_test_f*sin(ang_test_rad);
    static double ct1[MAX_BINS];
    static double ct2[(MAX_BINS)];
    static double ct3[(MAX_BINS)];
    static double c2[(MAX_BINS)];
    static double c3[(MAX_BINS)];
    static double c4[(MAX_BINS)];
    static double tauxArr[(MAX_BINS)];
    static double tauyArr[(MAX_BINS)];
    static double tauzArr[(MAX_BINS)];
    static double ieDotArr[(MAX_BINS)];
    static double ieDot2Arr[(MAX_BINS)];
    static double ieDot3Arr[(MAX_BINS)];

    for (int i =0; i<bins; i++){
        ct1[i]=0;
        ct2[i]=0;
        ct3[i]=0;
        c2[i]=0;
        c3[i]=0;
        c4[i]=0;
        tauxArr[i]=0;
        tauyArr[i]=0;
        tauzArr[i]=0;
        ieDotArr[i]=0;
        ieDot2Arr[i]=0;
        ieDot3Arr[i]=0;

    }

    double pre=1.0;
    // double tmp=0;
    struct tup res;

    // printf("%lf\n", r->particles[N*bins].x);
    for (int i=0; i<N*bins; i++){
        #pragma omp parallel for private(res)
        for (int j=0; j<bins; j++){
            double x=xs.array[i];
            double y=ys.array[i];
            double z=zs.array[i];

            double xTest=xs.array[N*bins+j];
            double yTest=ys.array[N*bins+j];
            double zTest=zs.array[N*bins+j];
            double vx=vxs.array[N*bins+j];
            double vy=vys.array[N*bins+j];
            double vz=vzs.array[N*bins+j];
            double phi = farr[j];

            double d=pow(pow(x-xTest, 2.)+pow(y-yTest,2.)+pow(z-zTest,2.),0.5);
            double forcex = -pow(m,2.0)/pow(d,3.0)*(xTest-x);
            double forcey = -pow(m,2.0)/pow(d,3.0)*(yTest-y);
            double forcez = -pow(m,2.0)/pow(d,3.0)*(zTest-z);

            double taux= (yTest*forcez-zTest*forcey);
            double tauy= -(xTest*forcez-zTest*forcex);
            double tauz= (xTest*forcey-yTest*forcex);

            res=comp_sum(tauzArr[j], tauz, ct1[j]);
            ct1[j]=res.c;
            tauzArr[j]=res.sum;

            res=comp_sum(tauxArr[j], taux, ct2[j]);
            ct2[j]=res.c;
            tauxArr[j]=res.sum;

            res=comp_sum(tauyArr[j], tauy, ct3[j]);
            ct3[j]=res.c;
            tauyArr[j]=res.sum;
            // printf("a: %d\n", j);


            //Angular momentum of test orbit--Take this to be in the xy plane
            double jz = xTest*vy-yTest*vx;
            double fr=forcex*cos(phi+ang_test_rad)+forcey*sin(phi+ang_test_rad);
            double vr=vx*cos(phi+ang_test_rad)+vy*sin(phi+ang_test_rad);
            double tmp = pre*(-jz*fr/e_test_f*(cos(phi)));

            res=comp_sum(ieDot2Arr[j], tmp, c2[j]);
            c2[j]=res.c;
            ieDot2Arr[j]=res.sum;

            tmp = pre*(-jz*fr/e_test_f*(cos(phi))+tauz*vr/e_test_f*(2/e_test_f+cos(phi)));
            res=comp_sum(ieDotArr[j], tmp, c3[j]);
            c3[j]=res.c;
            ieDotArr[j]=res.sum;

            double edotx=forcey*jz+(vy*tauz-vz*tauy);
            double edoty=-forcex*jz-(vx*tauz-vz*taux);
            tmp=((ex*edoty-ey*edotx)/(e_test_f*e_test_f));
            res=comp_sum(ieDot3Arr[j], tmp, c4[j]);
            c4[j]=res.c;
            ieDot3Arr[j]=res.sum;


       }

    }
    // double ieDot=(ex*edoty-ey*edotx)/pow(e_test_f, 2.);
    double tauxTot=sum_arr(tauxArr, bins);
    double tauyTot=sum_arr(tauyArr, bins);
    double tauzTot=sum_arr(tauzArr, bins);
    double ieDot=sum_arr(ieDotArr, bins);
    double ieDot2=sum_arr(ieDot2Arr, bins);
    double ieDot3=sum_arr(ieDot3Arr, bins);


    char tag2[80]="";
    strcat(tag2, "N");
    snprintf(tag2+strlen(tag2), sizeof(tag2), "%d", N);
    strcat(tag2, "_");
    strcat(tag2, tag);
    strcat(tag2, "_e");
    strcat(tag2, e_test);
    strcat(tag2, "_a");
    strcat(tag2, a_test);
    strcat(tag2, "_o");
    strcat(tag2, ang_test);
    strcat(tag2, "_q");
    strcat(tag2, q_disk);
    strcat(tag2, "_ein");
    strcat(tag2, e_in);
    strcat(tag2, "_dt");
    strcat(tag2, disk_tag);

    out("tau", tag2, tauxTot);
    outa("tau", tag2, tauyTot);
    outa("tau", tag2, tauzTot);

    out("i", tag2, ieDot);
    out("i2", tag2, ieDot2);
    out("i3", tag2, ieDot3);

    return 0;
}


